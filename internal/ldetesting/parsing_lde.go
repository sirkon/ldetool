// Code generated by ldetool --little-endian --package ldetesting parsing.lde. DO NOT EDIT.

package ldetesting

import (
	"bytes"
	"fmt"
	"github.com/sirkon/decconv"
	"strconv"
	"unsafe"
)

var constAnonymousAreasSpace = []byte(" ")
var constDecodersBoundedStringSpace = []byte(" ")
var constDecodersBoundedStringStressSpace = []byte(" ")
var constDecodersLimitedStringSpace = []byte(" ")
var constDecodersLimitedStringStressSpace = []byte(" ")
var constDecodersStringSpace = []byte(" ")
var constDecodersStringStressSpace = []byte(" ")
var constFixedLookConstFixedLook123456789 = []byte("123456789")
var constFixedLookConstFixedLook34 = []byte("34")
var constIncludeStringAb = []byte("ab")
var constJumpDogs = []byte("@@")
var constJustToCompileStringAbcd = []byte("abcd")
var constLookupJumpDogs = []byte("@@")
var constLookupJumpEe = []byte("ee")
var constLookupJumpLl = []byte("ll")
var constPrefixesConstPrefixes123456789 = []byte("123456789")
var constShift1Ba = []byte("ba")
var constShift3Ba = []byte("ba")
var constSplitStringBar = []byte("|")
var constStarBar = []byte("|")

// Decoders ...
type Decoders struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *Decoders) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimited ...
type DecodersLimited struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimited) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(tmpRest))
	}

	return true, nil
}

// DecodersBounded ...
type DecodersBounded struct {
	Rest  []byte
	Int64 int64
}

// Extract ...
func (p *DecodersBounded) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	var tmpRest []byte

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+1+8:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersString ...
type DecodersString struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.Rest, constDecodersStringSpace)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringSpace):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersLimitedString ...
type DecodersLimitedString struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until " " as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringSpace)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringSpace):]
	} else {
		return false, nil
	}

	return true, nil
}

// DecodersBoundedString ...
type DecodersBoundedString struct {
	Rest    []byte
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpRest []byte

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.Index(tmpRest, constDecodersBoundedStringSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+len(constDecodersBoundedStringSpace)+8:]
	} else {
		return false, nil
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecodersStress ...
type DecodersStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(p.Rest))
	}

	return true, nil
}

// DecodersLimitedStress ...
type DecodersLimitedStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until ' ' as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until ' ' as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until ' ' as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until ' ' as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until ' ' as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until ' ' as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until ' ' as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", ' ', string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until ' ' as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until ' ' as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", ' ', string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until ' ' as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field String", ' ', string(tmpRest))
	}

	return true, nil
}

// DecodersBoundedStress ...
type DecodersBoundedStress struct {
	Rest  []byte
	Int64 int64
}

// Extract ...
func (p *DecodersBoundedStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64
	var tmpRest []byte

	// Take until ' ' as Int64(int64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.IndexByte(tmpRest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+1+8:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", ' ', string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	return true, nil
}

// DecodersStringStress ...
type DecodersStringStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersStringStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpUint uint64

	// Take until " " as Int8(int8)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", constDecodersStringStressSpace, string(p.Rest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	pos = bytes.Index(p.Rest, constDecodersStringStressSpace)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", constDecodersStringStressSpace, string(p.Rest))
	}

	return true, nil
}

// DecodersLimitedStringStress ...
type DecodersLimitedStringStress struct {
	Rest    []byte
	Int8    int8
	Int16   int16
	Int32   int32
	Int64   int64
	Uint8   uint8
	Uint16  uint16
	Uint32  uint32
	Uint64  uint64
	Float32 float32
	Float64 float64
	String  []byte
}

// Extract ...
func (p *DecodersLimitedStringStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpInt int64
	var tmpRest []byte
	var tmpUint uint64

	// Take until " " as Int8(int8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)

	// Take until " " as Int16(int16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int16", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int16(int16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int16 = int16(tmpInt)

	// Take until " " as Int32(int32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int32", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int32(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int32 = int32(tmpInt)

	// Take until " " as Int64(int64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Int64", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int64(int64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int64 = int64(tmpInt)

	// Take until " " as Uint8(uint8)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint8", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint8(uint8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint8 = uint8(tmpUint)

	// Take until " " as Uint16(uint16)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint16", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint16(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint16 = uint16(tmpUint)

	// Take until " " as Uint32(uint32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint32", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint32(uint32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint32 = uint32(tmpUint)

	// Take until " " as Uint64(uint64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Uint64", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Uint64(uint64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Uint64 = uint64(tmpUint)

	// Take until " " as Float32(float32)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float32", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float32(float32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float32 = float32(tmpFloat)

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", constDecodersLimitedStringStressSpace, string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	// Take until " " as String(string)
	if len(p.Rest) >= 8 {
		tmpRest = p.Rest[:8]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.Index(tmpRest, constDecodersLimitedStringStressSpace)
	if pos >= 0 {
		p.String = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constDecodersLimitedStringStressSpace):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field String", constDecodersLimitedStringStressSpace, string(tmpRest))
	}

	return true, nil
}

// DecodersBoundedStringStress ...
type DecodersBoundedStringStress struct {
	Rest    []byte
	Float64 float64
}

// Extract ...
func (p *DecodersBoundedStringStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpFloat float64
	var tmpRest []byte

	// Take until " " as Float64(float64)
	if len(p.Rest) >= 16 {
		tmpRest = p.Rest[8:16]
	} else {
		tmpRest = p.Rest[8:]
	}
	pos = bytes.Index(tmpRest, constDecodersBoundedStringStressSpace)
	if pos >= 0 {
		tmp = p.Rest[:pos+8]
		p.Rest = p.Rest[pos+len(constDecodersBoundedStringStressSpace)+8:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Float64", constDecodersBoundedStringStressSpace, string(tmpRest))
	}
	if tmpFloat, err = strconv.ParseFloat(*(*string)(unsafe.Pointer(&tmp)), 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Float64(float64): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Float64 = float64(tmpFloat)

	return true, nil
}

// DecoderOptionals ...
type DecoderOptionals struct {
	Rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderOptionals) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var headRest []byte
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)
	headRest = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&0xffffffffff == 0x3d64616568 {
		headRest = headRest[5:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsHeadLabel
	}

	p.Head.Valid = true
	p.Rest = headRest
decoderoptionalsHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if len(p.Rest) >= 3 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffff == 0x646e65 {
		p.Rest = p.Rest[3:]
	} else {
		return false, nil
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionals) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderOptionalsStress ...
type DecoderOptionalsStress struct {
	Rest []byte
	Int8 int8
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderOptionalsStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var headRest []byte
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until ' ' as Int8(int8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Int8", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Int8(int8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Int8 = int8(tmpInt)
	headRest = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&0xffffffffff == 0x3d64616568 {
		headRest = headRest[5:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}

	// Take until ' ' as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Valid = false
		goto decoderoptionalsstressHeadLabel
	}

	p.Head.Valid = true
	p.Rest = headRest
decoderoptionalsstressHeadLabel:

	// Checks if the rest starts with `"end"` and pass it
	if len(p.Rest) >= 3 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffff == 0x646e65 {
		p.Rest = p.Rest[3:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest), "end")
	}

	return true, nil
}

// GetHeadData ...
func (p *DecoderOptionalsStress) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranching ...
type DecoderBranching struct {
	Rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderBranching) Extract(line []byte) (bool, error) {
	p.Rest = line
	var headRest []byte
	var pos int

	// Checks if the rest starts with `"start "` and pass it
	if len(p.Rest) >= 6 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffffffffff == 0x207472617473 {
		p.Rest = p.Rest[6:]
	}
	headRest = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&0xffffffffff == 0x3d64616568 {
		headRest = headRest[5:]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Data = headRest
		headRest = headRest[len(headRest):]
	}

	p.Head.Valid = true
	p.Rest = headRest

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranching) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DecoderBranchingStress ...
type DecoderBranchingStress struct {
	Rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DecoderBranchingStress) Extract(line []byte) (bool, error) {
	p.Rest = line
	var headRest []byte
	var pos int

	// Checks if the rest starts with `"start "` and pass it
	if len(p.Rest) >= 6 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffffffffff == 0x207472617473 {
		p.Rest = p.Rest[6:]
	}
	headRest = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&0xffffffffff == 0x3d64616568 {
		headRest = headRest[5:]
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Data = headRest
		headRest = headRest[len(headRest):]
	}

	p.Head.Valid = true
	p.Rest = headRest

	return true, nil
}

// GetHeadData ...
func (p *DecoderBranchingStress) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// DoubleOpts ...
type DoubleOpts struct {
	Rest []byte
	Head struct {
		Valid bool
		Data  []byte
	}
	Rest1 struct {
		Valid bool
		Data  []byte
	}
}

// Extract ...
func (p *DoubleOpts) Extract(line []byte) (bool, error) {
	p.Rest = line
	var headRest []byte
	var pos int
	var rest1Rest []byte
	headRest = p.Rest

	// Checks if the rest starts with `"head="` and pass it
	if len(headRest) >= 5 && *(*uint64)(unsafe.Pointer(&headRest[0]))&0xffffffffff == 0x3d64616568 {
		headRest = headRest[5:]
	} else {
		p.Head.Valid = false
		goto doubleoptsHeadLabel
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(headRest, ' ')
	if pos >= 0 {
		p.Head.Data = headRest[:pos]
		headRest = headRest[pos+1:]
	} else {
		p.Head.Data = headRest
		headRest = headRest[len(headRest):]
	}

	p.Head.Valid = true
	p.Rest = headRest
doubleoptsHeadLabel:
	rest1Rest = p.Rest

	// Checks if the rest starts with `"rest="` and pass it
	if len(rest1Rest) >= 5 && *(*uint64)(unsafe.Pointer(&rest1Rest[0]))&0xffffffffff == 0x3d74736572 {
		rest1Rest = rest1Rest[5:]
	} else {
		p.Rest1.Valid = false
		goto doubleoptsRest1Label
	}

	// Take until ' ' (or all the rest if not found) as Data(string)
	pos = bytes.IndexByte(rest1Rest, ' ')
	if pos >= 0 {
		p.Rest1.Data = rest1Rest[:pos]
		rest1Rest = rest1Rest[pos+1:]
	} else {
		p.Rest1.Data = rest1Rest
		rest1Rest = rest1Rest[len(rest1Rest):]
	}

	p.Rest1.Valid = true
	p.Rest = rest1Rest
doubleoptsRest1Label:

	return true, nil
}

// GetHeadData ...
func (p *DoubleOpts) GetHeadData() (res []byte) {
	if p.Head.Valid {
		res = p.Head.Data
	}
	return
}

// GetRest1Data ...
func (p *DoubleOpts) GetRest1Data() (res []byte) {
	if p.Rest1.Valid {
		res = p.Rest1.Data
	}
	return
}

// Prefixes ...
type Prefixes struct {
	Rest  []byte
	Data  int32
	Rest1 int32
}

// Extract ...
func (p *Prefixes) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Checks if the rest starts with `"123456789"` and pass it
	if bytes.HasPrefix(p.Rest, constPrefixesConstPrefixes123456789) {
		p.Rest = p.Rest[len(constPrefixesConstPrefixes123456789):]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest), "123456789")
	}

	// Take until ' ' as Data(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Data(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Data = int32(tmpInt)

	// Checks if the rest starts with `"12345"` and pass it
	if len(p.Rest) >= 5 && *(*uint64)(unsafe.Pointer(&p.Rest[0]))&0xffffffffff == 0x3534333231 {
		p.Rest = p.Rest[5:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest), "12345")
	}

	// Take until ' ' as Rest1(int32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest1", ' ', string(p.Rest))
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Rest1(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Rest1 = int32(tmpInt)

	return true, nil
}

// FixedLook ...
type FixedLook struct {
	Rest  []byte
	Data  int32
	Rest1 int32
}

// Extract ...
func (p *FixedLook) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var tmp []byte
	var tmpInt int64

	// Take until 3rd character  if that part is started by "123456789" substring as Data(int32)
	if len(p.Rest) < len(constFixedLookConstFixedLook123456789)+2 || !bytes.HasPrefix(p.Rest[2:], constFixedLookConstFixedLook123456789) {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Data", constFixedLookConstFixedLook123456789, string(p.Rest))
	}
	tmp = p.Rest[:2]
	p.Rest = p.Rest[2+len(constFixedLookConstFixedLook123456789):]
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Data(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Data = int32(tmpInt)

	// Take until 4th character  if that part is started by "34" substring as Rest1(int32)
	if len(p.Rest)-3 < 2 || *(*uint64)(unsafe.Pointer(&p.Rest[3]))&0xffff != 0x3433 {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Rest1", constFixedLookConstFixedLook34, string(p.Rest))
	}
	tmp = p.Rest[:3]
	p.Rest = p.Rest[3+len(constFixedLookConstFixedLook34):]
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Rest1(int32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Rest1 = int32(tmpInt)

	return true, nil
}

// AnonymousAreas ...
type AnonymousAreas struct {
	Rest []byte
	Data []byte
}

// Extract ...
func (p *AnonymousAreas) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var rest []byte
	rest = p.Rest

	// Looking for 'd' and then pass it
	pos = -1
	for i, char := range rest {
		if char == 'd' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		rest = rest[pos+1:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}

	// Checks if the rest starts with `"ata="` and pass it
	if len(rest) >= 4 && *(*uint64)(unsafe.Pointer(&rest[0]))&0xffffffff == 0x3d617461 {
		rest = rest[4:]
	} else {
		goto anonymousareasAnonymousAreaLabel
	}
	p.Rest = rest
anonymousareasAnonymousAreaLabel:
	rest = p.Rest

	// Checks if the rest starts with `"1234"` and pass it
	if len(rest) >= 4 && *(*uint64)(unsafe.Pointer(&rest[0]))&0xffffffff == 0x34333231 {
		rest = rest[4:]
	} else {
		goto anonymousareasAnonymousAreaLabel2
	}
	p.Rest = rest
anonymousareasAnonymousAreaLabel2:

	// Take until " " (or all the rest if not found) as Data(string)
	pos = bytes.Index(p.Rest, constAnonymousAreasSpace)
	if pos >= 0 {
		p.Data = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constAnonymousAreasSpace):]
	} else {
		p.Data = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}

	return true, nil
}

// Split ...
type Split struct {
	Rest  []byte
	Name  []byte
	Count []byte
}

// Extract ...
func (p *Split) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Take until '|' as Name(string)
	pos = -1
	for i, char := range p.Rest {
		if char == '|' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Name = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Name", '|', string(p.Rest))
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		p.Rest = p.Rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.Rest), "'|'")
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		p.Rest = p.Rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.Rest), "'|'")
	}

	// Checks if rest[1:] starts with '|' and pass it
	if len(p.Rest) >= 1+1 && p.Rest[1] == '|' {
		p.Rest = p.Rest[1+1:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m)` is expected to start with \033[1m%s\033[0m", string(p.Rest), "'|'")
	}

	// Take until 2nd character  if it is equal to '|' character as Count(string)
	if len(p.Rest) < 1+1 || p.Rest[1] != '|' {
		return false, fmt.Errorf("%s element in the rest is not `\033[1m%c\033[0m` in `\033[1m%s\033[0m`, cannot bound data for field Count", "2nd", '|', string(p.Rest))
	}
	p.Count = p.Rest[:1]
	p.Rest = p.Rest[1+1:]

	return true, nil
}

// SplitString ...
type SplitString struct {
	Rest  []byte
	Name  []byte
	Count []byte
}

// Extract ...
func (p *SplitString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Take until "|" as Name(string)
	pos = bytes.Index(p.Rest, constSplitStringBar)
	if pos >= 0 {
		p.Name = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constSplitStringBar):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Name", constSplitStringBar, string(p.Rest))
	}

	// Checks if rest[1:] starts with `"|"` and pass it
	if len(p.Rest)-1 >= 1 && *(*uint64)(unsafe.Pointer(&p.Rest[1]))&0xff == 0x7c {
		p.Rest = p.Rest[2:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest[1:]), "|")
	}

	// Checks if rest[1:] starts with `"|"` and pass it
	if len(p.Rest)-1 >= 1 && *(*uint64)(unsafe.Pointer(&p.Rest[1]))&0xff == 0x7c {
		p.Rest = p.Rest[2:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest[1:]), "|")
	}

	// Checks if rest[1:] starts with `"|"` and pass it
	if len(p.Rest)-1 >= 1 && *(*uint64)(unsafe.Pointer(&p.Rest[1]))&0xff == 0x7c {
		p.Rest = p.Rest[2:]
	} else {
		return false, fmt.Errorf("`\033[1m%s\033[0m` is expected to start with `\033[1m%s\033[0m`", string(p.Rest[1:]), "|")
	}

	// Take until 2nd character  if that part is started by "|" substring as Count(string)
	if len(p.Rest)-1 < 1 || *(*uint64)(unsafe.Pointer(&p.Rest[1]))&0xff != 0x7c {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Count", constSplitStringBar, string(p.Rest))
	}
	p.Count = p.Rest[:1]
	p.Rest = p.Rest[1+len(constSplitStringBar):]

	return true, nil
}

// Shift1 ...
type Shift1 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift1) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until "ba" as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = bytes.Index(tmpRest, constShift1Ba)
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+len(constShift1Ba)+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field B", constShift1Ba, string(tmpRest))
	}

	return true, nil
}

// Shift2 ...
type Shift2 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift2) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until 'b' as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = bytes.IndexByte(tmpRest, 'b')
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+1+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field B", 'b', string(tmpRest))
	}

	return true, nil
}

// Shift3 ...
type Shift3 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift3) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until "ba" as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = bytes.Index(tmpRest, constShift3Ba)
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+len(constShift3Ba)+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field B", constShift3Ba, string(tmpRest))
	}

	return true, nil
}

// Shift4 ...
type Shift4 struct {
	Rest []byte
	B    []byte
}

// Extract ...
func (p *Shift4) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Take until 'b' as B(string)
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[3:12]
	} else {
		tmpRest = p.Rest[3:]
	}
	pos = -1
	for i, char := range tmpRest {
		if char == 'b' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.B = p.Rest[:pos+3]
		p.Rest = p.Rest[pos+1+3:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field B", 'b', string(tmpRest))
	}

	return true, nil
}

// Jump ...
type Jump struct {
	Rest   []byte
	First  []byte
	Second []byte
	Third  []byte
	Fourth []byte
}

// Extract ...
func (p *Jump) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Take until ' ' as First(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.IndexByte(p.Rest[2:], ' ')
	if pos >= 0 {
		p.First = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field First", ' ', string(p.Rest[2:]))
	}

	// Take until ' ' as Second(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = -1
	for i, char := range p.Rest[2:] {
		if char == ' ' {
			pos = i
			break
		}
	}
	if pos >= 0 {
		p.Second = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%c\033[0m` in `\033[1m%s\033[0m` to bound data for field Second", ' ', string(p.Rest[2:]))
	}

	// Take until "@@" as Third(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.Index(p.Rest[2:], constJumpDogs)
	if pos >= 0 {
		p.Third = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+len(constJumpDogs)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Third", constJumpDogs, string(p.Rest[2:]))
	}

	// Take until "@@" as Fourth(string)
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.Index(p.Rest[2:], constJumpDogs)
	if pos >= 0 {
		p.Fourth = p.Rest[:pos+2]
		p.Rest = p.Rest[pos+len(constJumpDogs)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m` to bound data for field Fourth", constJumpDogs, string(p.Rest[2:]))
	}

	return true, nil
}

// LookupJump ...
type LookupJump struct {
	Rest []byte
}

// Extract ...
func (p *LookupJump) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmpRest []byte

	// Looking for ' ' and then pass it
	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	pos = bytes.IndexByte(p.Rest[2:], ' ')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "' '", string(p.Rest[2:]))
	}

	if len(p.Rest) < 2 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 2, len(p.Rest), string(p.Rest))
	}
	// Looking for "@@" and then pass it
	pos = bytes.Index(p.Rest[2:], constLookupJumpDogs)
	if pos >= 0 {
		p.Rest = p.Rest[pos+len(constLookupJumpDogs)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", constLookupJumpDogs, string(p.Rest[2:]))
	}

	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[:12]
	} else {
		tmpRest = p.Rest
	}
	// Looking for "ll" and then pass it
	pos = bytes.Index(tmpRest, constLookupJumpLl)
	if pos >= 0 {
		p.Rest = p.Rest[pos+len(constLookupJumpLl):]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", constLookupJumpLl, string(tmpRest))
	}

	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[2:12]
	} else {
		tmpRest = p.Rest[2:]
	}
	// Looking for "ee" and then pass it
	pos = bytes.Index(tmpRest, constLookupJumpEe)
	if pos >= 0 {
		p.Rest = p.Rest[pos+len(constLookupJumpEe)+2:]
	} else {
		return false, fmt.Errorf("cannot find `\033[1m%s\033[0m` in `\033[1m%s\033[0m`", constLookupJumpEe, string(tmpRest))
	}

	// Looking for 'e' and then pass it
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[:12]
	} else {
		tmpRest = p.Rest
	}
	pos = bytes.IndexByte(tmpRest, 'e')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "'e'", string(tmpRest))
	}

	// Looking for 'f' and then pass it
	if len(p.Rest) >= 12 {
		tmpRest = p.Rest[2:12]
	} else {
		tmpRest = p.Rest[2:]
	}
	pos = bytes.IndexByte(tmpRest, 'f')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+2:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "'f'", string(tmpRest))
	}

	return true, nil
}

// TargetConstraintsCheck ...
type TargetConstraintsCheck struct {
	Rest []byte
}

// Extract ...
func (p *TargetConstraintsCheck) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int

	// Looking for ' ' and then pass it
	if len(p.Rest) < 1 {
		return false, nil
	}
	pos = bytes.IndexByte(p.Rest[1:], ' ')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+1:]
	} else {
		return false, nil
	}

	// Looking for ' ' and then pass it
	if len(p.Rest) < 1 {
		return false, fmt.Errorf("cannot slice from %d as only %d characters left in the rest (`\033[1m%s\033[0m`)", 1, len(p.Rest), string(p.Rest))
	}
	pos = bytes.IndexByte(p.Rest[1:], ' ')
	if pos >= 0 {
		p.Rest = p.Rest[pos+1+1:]
	} else {
		return false, fmt.Errorf("cannot find \033[1m%s\033[0m in `\033[1m%s\033[0m`", "' '", string(p.Rest[1:]))
	}

	return true, nil
}

// URL ...
type URL struct {
	Rest     []byte
	UserPass struct {
		Valid    bool
		User     []byte
		Password []byte
	}
	User struct {
		Valid bool
		User  []byte
	}
	Host   []byte
	Port   uint16
	DBName []byte
}

// Extract ...
func (p *URL) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64
	var userPassRest []byte
	var userRest []byte
	userPassRest = p.Rest

	// Take until ':' as User(string)
	if len(userPassRest) < 1 {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	pos = bytes.IndexByte(userPassRest[1:], ':')
	if pos >= 0 {
		p.UserPass.User = userPassRest[:pos+1]
		userPassRest = userPassRest[pos+1+1:]
	} else {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}

	// Take until '@' as Password(string)
	if len(userPassRest) < 1 {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}
	pos = bytes.IndexByte(userPassRest[1:], '@')
	if pos >= 0 {
		p.UserPass.Password = userPassRest[:pos+1]
		userPassRest = userPassRest[pos+1+1:]
	} else {
		p.UserPass.Valid = false
		goto urlUserPassLabel
	}

	p.UserPass.Valid = true
	p.Rest = userPassRest
urlUserPassLabel:
	userRest = p.Rest

	// Take until '@' as User(string)
	if len(userRest) < 1 {
		p.User.Valid = false
		goto urlUserLabel
	}
	pos = bytes.IndexByte(userRest[1:], '@')
	if pos >= 0 {
		p.User.User = userRest[:pos+1]
		userRest = userRest[pos+1+1:]
	} else {
		p.User.Valid = false
		goto urlUserLabel
	}

	p.User.Valid = true
	p.Rest = userRest
urlUserLabel:

	// Take until ':' as Host(string)
	if len(p.Rest) < 1 {
		return false, nil
	}
	pos = bytes.IndexByte(p.Rest[1:], ':')
	if pos >= 0 {
		p.Host = p.Rest[:pos+1]
		p.Rest = p.Rest[pos+1+1:]
	} else {
		return false, nil
	}

	// Take until '/' (or all the rest if not found) as Port(uint16)
	pos = bytes.IndexByte(p.Rest, '/')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		tmp = p.Rest
		p.Rest = p.Rest[len(p.Rest):]
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 10, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Port(uint16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Port = uint16(tmpUint)

	// Take the rest as DBName(string)
	p.DBName = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// GetUserPassUser ...
func (p *URL) GetUserPassUser() (res []byte) {
	if p.UserPass.Valid {
		res = p.UserPass.User
	}
	return
}

// GetUserPassPassword ...
func (p *URL) GetUserPassPassword() (res []byte) {
	if p.UserPass.Valid {
		res = p.UserPass.Password
	}
	return
}

// GetUserUser ...
func (p *URL) GetUserUser() (res []byte) {
	if p.User.Valid {
		res = p.User.User
	}
	return
}

// IncludeChar ...
type IncludeChar struct {
	Rest   []byte
	Data   []byte
	Field2 int
}

// Extract ...
func (p *IncludeChar) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until '@' including it as Data(string)
	pos = bytes.IndexByte(p.Rest, '@')
	if pos >= 0 {
		p.Data = p.Rest[:pos+1]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}

	// Take until '@' as Field2(int)
	pos = bytes.IndexByte(p.Rest, '@')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Field2(int): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Field2 = int(tmpInt)

	return true, nil
}

// IncludeString ...
type IncludeString struct {
	Rest   []byte
	Data   []byte
	Field2 int
}

// Extract ...
func (p *IncludeString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpInt int64

	// Take until "ab" including it  as Data(string)
	pos = bytes.Index(p.Rest, constIncludeStringAb)
	if pos >= 0 {
		p.Data = p.Rest[:pos+len(constIncludeStringAb)]
		p.Rest = p.Rest[pos+len(constIncludeStringAb):]
	} else {
		return false, nil
	}

	// Take until "ab" as Field2(int)
	pos = bytes.Index(p.Rest, constIncludeStringAb)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constIncludeStringAb):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Field2(int): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Field2 = int(tmpInt)

	return true, nil
}

// Hex ...
type Hex struct {
	Rest []byte
	F1   uint
	F2   uint8
	F3   uint16
	F4   uint32
	F5   uint64
}

// Extract ...
func (p *Hex) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until ' ' as F1(hex)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F1(hex): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F1 = uint(tmpUint)

	// Take until ' ' as F2(hex8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F2(hex8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F2 = uint8(tmpUint)

	// Take until ' ' as F3(hex16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F3(hex16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F3 = uint16(tmpUint)

	// Take until ' ' as F4(hex32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F4(hex32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F4 = uint32(tmpUint)

	// Take the rest as F5(hex64)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 16, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F5(hex64): %s", string(*(*string)(unsafe.Pointer(&p.Rest))), err)
	}
	p.F5 = uint64(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// Oct ...
type Oct struct {
	Rest []byte
	F1   uint
	F2   uint8
	F3   uint16
	F4   uint32
	F5   uint64
}

// Extract ...
func (p *Oct) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte
	var tmpUint uint64

	// Take until ' ' as F1(oct)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F1(oct): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F1 = uint(tmpUint)

	// Take until ' ' as F2(oct8)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F2(oct8): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F2 = uint8(tmpUint)

	// Take until ' ' as F3(oct16)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 8); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F3(oct16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F3 = uint16(tmpUint)

	// Take until ' ' as F4(oct32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 8, 32); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F4(oct32): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F4 = uint32(tmpUint)

	// Take the rest as F5(oct64)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 8, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F5(oct64): %s", string(*(*string)(unsafe.Pointer(&p.Rest))), err)
	}
	p.F5 = uint64(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// Dec ...
type Dec struct {
	Rest []byte
	F1   int32
	F2   int64
	F3   struct {
		Lo uint64
		Hi uint64
	}
}

// Extract ...
func (p *Dec) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var pos int
	var tmp []byte

	// Take until ' ' as F1(dec32)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.F1, err = decconv.Decode32(8, 3, tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F1(dec8.3): %s", string(string(tmp)), err)
	}

	// Take until ' ' as F2(dec64)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	if p.F2, err = decconv.Decode64(12, 2, tmp); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F2(dec12.2): %s", string(string(tmp)), err)
	}

	// Take the rest as F3(dec128)
	if p.F3.Lo, p.F3.Hi, err = decconv.Decode128(30, 8, p.Rest); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F3(dec30.8): %s", string(string(p.Rest)), err)
	}
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// RestLength ...
type RestLength struct {
	Rest []byte
}

// Extract ...
func (p *RestLength) Extract(line []byte) (bool, error) {
	p.Rest = line

	// checks if the rest is exactly 15 characters long
	if len(p.Rest) != 15 {
		return false, nil
	}

	// checks if the rest is less than 16 characters long
	if len(p.Rest) >= 16 {
		return false, nil
	}

	// checks if the rest is more than 14 characters long
	if len(p.Rest) <= 14 {
		return false, nil
	}

	return true, nil
}

// Str ...
type Str struct {
	Rest []byte
	F1   string
	F2   []byte
}

// Extract ...
func (p *Str) Extract(line []byte) (bool, error) {
	p.Rest = line
	var pos int
	var tmp []byte

	// Take until ' ' as F1(str)
	pos = bytes.IndexByte(p.Rest, ' ')
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+1:]
	} else {
		return false, nil
	}
	p.F1 = string(tmp)

	// Take the rest as F2(string)
	p.F2 = p.Rest
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// Star ...
type Star struct {
	Rest []byte
	F    int
	B    int
}

// Extract ...
func (p *Star) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var headPassCounter int
	var headPassValue byte
	var pos int
	var tmp []byte
	var tmpInt int64

	// Pass all characters 'a' at the rest start
	for headPassCounter, headPassValue = range p.Rest {
		if headPassValue != 'a' {
			break
		}
	}
	if headPassCounter > 0 {
		p.Rest = p.Rest[headPassCounter:]
	}

	// Take until "|" as F(int)
	pos = bytes.Index(p.Rest, constStarBar)
	if pos >= 0 {
		tmp = p.Rest[:pos]
		p.Rest = p.Rest[pos+len(constStarBar):]
	} else {
		return false, nil
	}
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&tmp)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field F(int): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.F = int(tmpInt)

	// Pass all characters 'a' at the rest start
	headPassCounter = 0
	for headPassCounter, headPassValue = range p.Rest {
		if headPassValue != 'a' {
			break
		}
	}
	if headPassCounter > 0 {
		p.Rest = p.Rest[headPassCounter:]
	}

	// Take the rest as B(int)
	if tmpInt, err = strconv.ParseInt(*(*string)(unsafe.Pointer(&p.Rest)), 10, 64); err != nil {
		return false, fmt.Errorf("parsing `%s` into field B(int): %s", string(*(*string)(unsafe.Pointer(&p.Rest))), err)
	}
	p.B = int(tmpInt)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// JustToCompile ...
type JustToCompile struct {
	Rest []byte
	Head uint16
	Tail uint16
}

// Extract ...
func (p *JustToCompile) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var tmp []byte
	var tmpUint uint64

	// Take until 5th character  if it is equal to '-' character as Head(hex16)
	if len(p.Rest) < 4+1 || p.Rest[4] != '-' {
		return false, nil
	}
	tmp = p.Rest[:4]
	p.Rest = p.Rest[4+1:]
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Head(hex16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Head = uint16(tmpUint)

	// Take the rest as Tail(hex16)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 16, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Tail(hex16): %s", string(*(*string)(unsafe.Pointer(&p.Rest))), err)
	}
	p.Tail = uint16(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// JustToCompileString ...
type JustToCompileString struct {
	Rest []byte
	Head uint16
	Tail uint16
}

// Extract ...
func (p *JustToCompileString) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error
	var tmp []byte
	var tmpUint uint64

	// Take until 5th character  if that part is started by "abcd" substring as Head(hex16)
	if len(p.Rest)-4 < 4 || *(*uint64)(unsafe.Pointer(&p.Rest[4]))&0xffffffff != 0x64636261 {
		return false, nil
	}
	tmp = p.Rest[:4]
	p.Rest = p.Rest[4+len(constJustToCompileStringAbcd):]
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&tmp)), 16, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Head(hex16): %s", string(*(*string)(unsafe.Pointer(&tmp))), err)
	}
	p.Head = uint16(tmpUint)

	// Take the rest as Tail(hex16)
	if tmpUint, err = strconv.ParseUint(*(*string)(unsafe.Pointer(&p.Rest)), 16, 16); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Tail(hex16): %s", string(*(*string)(unsafe.Pointer(&p.Rest))), err)
	}
	p.Tail = uint16(tmpUint)
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}

// CustomStr ...
type CustomStr struct {
	Rest []byte
	Data string
}

// Extract ...
func (p *CustomStr) Extract(line []byte) (bool, error) {
	p.Rest = line
	var err error

	// Take the rest as Data($str)
	if p.Data, err = p.unmarshalData(p.Rest); err != nil {
		return false, fmt.Errorf("parsing `%s` into field Data(str): %s", string(p.Rest), err)
	}
	p.Rest = p.Rest[len(p.Rest):]
	return true, nil
}
